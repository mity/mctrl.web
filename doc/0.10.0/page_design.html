<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>mCtrl: Design Notes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mCtrl
   &#160;<span id="projectnumber">0.10.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="files.html"><span>Header&#160;Files</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Design Notes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_error_handling"></a>
About Error Handling</h1>
<p>In general, mCtrl follows Win32API conventions in error handling. On error, the mCtrl functions set the error code with <code>SetLastError()</code> and then typically return a value indicating an error has occurred. In most cases this error indicator is 0, -1, <code>FALSE</code> or <code>NULL</code>, depending on the function and type it returns.</p>
<p>If a function fails, any output parameters are undefined and you cannot rely on their value.</p>
<p>Also note that for the category of caller's programmatic errors (e.g. when application specifies an invalid value in a function parameter or invalid combination of multiple parameters; or when calling any function without having the particular mCtrl module initialized), mCtrl uses very pragmatic approach: Such error conditions are only checked if it is reasonably easy to do so. Some more checks can be enabled in debug builds of mCtrl.</p>
<h1><a class="anchor" id="sec_strings"></a>
About Strings</h1>
<p><code>MCTRL.DLL</code> supports Unicode and strings held internally in the library are encoded in Unicode.</p>
<p>However on interface level, <code>MCTRL.DLL</code> supports both Unicode and ANSI strings as well. If a function, message of a control or a structure uses string, there are usually two flavors of the entity: one for Unicode and one for the ANSI string. When calling a function or sending a message, ANSI strings in parameters and structure members are converted to Unicode on input and Unicode to ANSI on output.</p>
<p>Identifiers of the Unicode flavor then have the <code>"W"</code> suffix and ANSI have <code>"A"</code> suffix, in the same way as Win32API does. The public headers also provide preprocessor macros without the suffix, as an alias for the one of the two depending whether <code>UNICODE</code> is defined or not.</p>
<p>In case of notifications sent by control to the application, the mCtrl also follows the Windows custom practice: Controls which may need to send a notification with string data send <code>WM_NOTIFYFORMAT</code> message to its parent during creation and then respect the parent's desire.</p>
<p>This means you may use <code>MCTRL.DLL</code> easily in Unicode-enabled application as well as in ANSI applications.</p>
<h1><a class="anchor" id="sec_init"></a>
About Initialization and Termination</h1>
<p>mCtrl functionality is divided into several modules, each having its own public header file. Almost every module corresponds to an implementation of one GUI control. With few trivial exceptions, each module has its own initialization and termination function.</p>
<p>Before you may use any functionality of the module you have to initialize it and after you stop using it you should terminate it to free any resources the module uses.</p>
<p>For controls, the initialization routine typically registers the control's window class with <code>RegisterClass()</code>, and the termination function unregisters it with <code>UnregisterClass()</code>.</p>
<p>Note that for performance reasons mCtrl functions do not test whether the module is properly initialized, so the function can fail in any means if the module is not initialized, or can work if the function does not currently rely on the initialization. But note that in the latter case there is no guaranty the behavior does not change in future versions of mCtrl.</p>
<p>The initialization function can be always called multiple times (even concurrently for multiple threads). Each module has its own initialization counter, incremented in the initialization function and decremented in the termination function. The module is really uninitialized only after the counter drops back down to zero.</p>
<dl class="section attention"><dt>Attention</dt><dd>Note that if you are using <code>MCTRL.DLL</code> from your dynamic library, you may not call the initialization and termination functions in context of <code>DllMain()</code>. Windows severly limits what can be done safely in the <code>DllMain()</code> context. Even if it would be safe for some modules currently there is no guaranty that future version of mCtrl won't use anything problematic in this regard.</dd></dl>
<h1><a class="anchor" id="sec_msg_constants"></a>
About Message Constants</h1>
<p>mCtrl makes this promise (valid also for future versions of <code>MCTRL.DLL</code>): All mCtrl controls only implement private messages in the range 0x0401 (<code>WM_USER</code> + 1) to 0x1299 (<code>WM_USER</code> + 0x0eff).</p>
<p>Beside that mCtrl controls support some common control general messages (<code>CCM_xxxx</code> which start at 0x2000; e.g. <code>CCM_SETUNICODEFORMAT</code>).</p>
<p>I.e., if an application implements some custom control as a subclass of mCtrl control, it should acquire its private message from the range 0x1300 to 0x1fff.</p>
<h1><a class="anchor" id="sec_multithreading"></a>
About Multi-threading</h1>
<p>mCtrl is designed to be multi-threading friendly. In general, all functions are reentrant. I.e. you can call the same <code>MCTRL.DLL</code> function concurrently from multiple threads.</p>
<p>However remember that access to data visible externally through <code>MCTRL.DLL</code> interface is not synchronized: If you have such data (e.g. <a class="el" href="table_8h.html#ab6375a1d52d2919a4af1118b21bca749">MC_HTABLE</a>) and then want to manipulate with the data concurrently in context of multiple threads, <code>MCTRL.DLL</code> does not synchronize for you: It's application developer's responsibility to do so in order to avoid race conditions.</p>
<p>Also note that some mCtrl modules may include yet another limitations. Any such limitations are described in documentation of such the particular modules. (The <a class="el" href="html_8h.html#a4e7287ac8d63dc1623b9ee6d0394594a">MC_WC_HTML</a> control is a prominent example of such limitation.)</p>
<p>Furthermore, some care is also needed if your application is multi-threaded and if it relies on any COM interface in any thread which may call into <code>MCTRL.DLL</code>. See <a class="el" href="page_design.html#sec_com">Compatibility with COM</a> for mroe information about this.</p>
<h1><a class="anchor" id="sec_com"></a>
Compatibility with COM</h1>
<dl class="section note"><dt>Note</dt><dd>In case you you can not understand what this section is about, and you are sure your application does not use COM, then all you need to know is this: Everything is alright. Skip this section and ignore it. mCtrl will just work.</dd></dl>
<p>Internally, implementation of some mCtrl features and modules is based on COM (Component Object Model). The COM uses the not so widely understood concept of thread apartments.</p>
<p>Each thread which wants to use COM, needs first to initialize the COM subsystem with function <code>CoInitialize()</code> or <code>CoInitializeEx()</code> or any function wrapping it (e.g. <code>OleInitialize()</code>). The function (or a parameter passed to it) then determines the thread's apartment. Once set, the thread apartment then cannot be changed.</p>
<p>This design may mean a problem when designing any DLL. The DLL can safely set COM apartment model for worker threads private to the DLL where the application has no chance to initialize it on its own. But in the usual case of an application thread which just calls arbitrary DLL function, calling <code>CoInitialize()</code> inside the DLL brings a risk: If both the DLL as well as the application want to use COM and they do not agree on common apartment model, the application will be subject of subtle and hard-to-debug bugs (the thread may live in other apartment then DLL or application thinks, the <code>CoInitialize()</code> may fail etc.)</p>
<p>This section therefore describes how <code>MCTRL.DLL</code> initializes and mananges COM and we recommend two ways how to deal with COM in application linking against <code>MCTRL.DLL</code>.</p>
<p>Actually, the rules are very simple:</p>
<ol type="1">
<li><code>MCTRL.DLL</code> implementation of any module or feature may or may not use COM as it sees fit. Even modules which do not yet do so today, may start to do so in any future version of mCtrl.</li>
<li><code>MCTRL.DLL</code> uses COM in a way which is compatible both with single-threaded apartments as well as multi-threaded apartments.</li>
<li>The very 1st time, when <code>MCTRL.DLL</code> needs to use COM, it detects whether the calling thread has COM subsystem already initialized or not. The result of this test then determines whether <code>MCTRL.DLL</code> does all COM initialization on its own or if it leaves it on the application. I.e. if the test says the COM is (for the current thread) already initialized, it tells <code>MCTRL.DLL</code> to never ever attempt to initialize COM anymore, in any thread, for the lifetime of the process (or until <code>MCTRL.DLL</code> is unloaded) as <code>MCTRL.DLL</code> considers the application to be COM-aware. However if the test detects that COM in the given thread is not yet initialized, the <code>MCTRL.DLL</code> assumes he application does not use COM at all, and it shall initialize COM as it sees fit for its own purposes to deal with it.</li>
<li>When <code>MCTRL.DLL</code> manages the COM initialization, application must not rely when it does so, and how it does so (i.e. what apartment <code>MCTRL.DLL</code> uses.) In other words, there should be no other COM usage but in <code>MCTRL.DLL</code>.</li>
</ol>
<p>Hence, any application which links with <code>MCTRL.DLL</code>, should strictly follow one of two use patterns as of COM initialization:</p>
<ol type="1">
<li><code>MCTRL.DLL</code> manages COM. Application must never perform COM initialization of any thread which may call into <code>MCTRL.DLL</code>. This is perfectly usable for applications which (on their own or through any 3rd party DLL) never use COM.</li>
<li>The application manages COM. This is required for applications which may use COM directly on their own or through any 3rd party DLL from any thread which also may call any mCtrl function. In this case, the application is responsible to initialize COM for each thread prior calling any mCtrl function in the given thread. The application can initialize COM for single-threaded or multi-threaded apartment as it sees fit. (However note that threads performing user-interface, should not use multi-threaded apartments. But this is, of course, raison d'Ãªtre of single-thread apartment and not limitation of mCtrl.)</li>
</ol>
<h1><a class="anchor" id="sec_dll_deps"></a>
DLL Dependencies</h1>
<p>The policy for mCtrl is to make hard dependencies only on DLLs available on on all supported Windows versions. This includes libraries like <code>USER32.DLL</code>, <code>COMMCTRL32.DLL</code> or <code>GDI32.DLL</code>.</p>
<p>However some mCtrl features may depend on additional DLLs, which are loaded in runtime. In such cases, mCtrl tries to behave in a reasonable manner even if those libraries or are not available.</p>
<ul>
<li><code>UXTHEME.DLL</code> is used on Windows XP and newer to paint the mCtrl controls using the current theme. Note mCtrl does so only if the application uses <code>COMMCTRL32.DLL</code> version 6 or newer.</li>
<li>In cases, that GDI is insufficient and higher-quality graphics is needed, mCtrl loads Direct2D (<code>D2D1.DLL</code>) &amp; DirectWrite (<code>DWRITE.DLL</code>), or if Direct2D/DirectWrite is not available, it loads GDI+ (<code>GDIPLUS.DLL</code>). Note that Direct2D is only available since MS Vista (with some service pack or other updates) and newer Windows versions. GDI+ is available since Windows XP. Windows 2000 does not provide system version of GDI+ but redistributable version of GDI+ v. 1.0 can be obtained from Microsoft. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
